# 8. 애그리거트 트랜잭션 관리

## 8.1 애그리거트와 트랜잭션
- 운영자와 고객이 동시에 한 주문 애그리거트를 수정하면 애그리거트의 일관성이 깨지게 된다.
- 일관성을 유지하려면 아래 두가지 중 하나를 해야 한다.
  - 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하도록 한다.
  - 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정한다.
- 위 두가지는 애그리거트의 트랜잭션과 관련이 있다. DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 기법이 필요하다.

## 8.2 선점 잠금
- 먼저 애그리거트를 구한 스레드가 애그리거트를 다 사용할 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하도록 한다.
- 운영자 스레드가 선점 잠금 방식으로 주문 애그리거트를 구하면 바로 뒤이어 고객 스레드는 대기 상태가 된다. 운영자 스레드가
  배송상태로 변경뒤 트랜잭션을 커밋하면 잠금을 해제한다. 이제 고객 스레드가 구한 애그리거트는 운영자가 배송상태를 변경한 애그리거트다.
  이미 배송중 상태이므로 더 이상 주소를 수정할 수 없다는 에러를 보게 된다.
- 선점 잠금은 보통 DBMS가 제공하는데 많은 DBMS가 특정 레코드에 한 스레드만 접근하도록 잠금장치를 제공한다.

## 8.2.1 선점 잠금과 교착상태
- 스레드 1은 A 애그리거트의 잠금을 구하고 스레드 2는 B 애그리거트 잠금을 구한 상태에서 스레드 1이 B 애그리거트 선점 잠금을 시도하고
  스레드 2가 A 애그리거트 선점 잠금을 시도하면 이는 교착상태로 빠지게 된다.
- 선점 잠금에 따른 교착상태는 사용자가 많을수록 발생할 가능성이 높다. 이런 문제를 발생하지 않도록 하려면 잠금을 구할때 최대 대기 시간을
  지정해야 한다.

## 8.3 비선점 잠금
- 선점 잠금으로 막을 수 없는 상황이 있는데 가령 운영자는 고객의 정보를 이미 조회해서 보는 상태이고 이때 고객이 주소를 변경해버렸다.
  이후에 운영자가 브라우저로 가져온 화면에서 배송중 상태로 변경하면 고객이 주소를 변경하기 전의 주소로 배송이 된다.
- 이때는 비선점 잠금이 필요하다. 동시에 접근하는 것을 막는대신 변경한 데이터르 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인해야 한다.
- 비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 한다.
- 애그리거트를 수정할 때 마다 버전으로 사용할 프로퍼티 값이 1씩 증가하는데 애그리거트 수정시점에 이 버전이 동일할 경우에만 데이터를 수정한다.
- JPA는 @Version 애노테이션으로 비선점 잠금 기능을 지원한다. 다음과 같이 버전으로 사용할 필드에 에너테이션을 붙인다.
```java
@Entity
public class Order { 
    @Version
    private long version;
}
```
