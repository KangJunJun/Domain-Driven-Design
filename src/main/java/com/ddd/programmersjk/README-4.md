# 4. 리포지터리와 모델 구현

## 4.1 JPA를 이용한 리포지터리 구현
- 리포지터리 인터페이스(JPA에서 우리가 작성하는 리포지터리)는 도메인 영여겡 속하고 실제 구현체(JPA를 쓴다면 JPQL을 쓰는 메소드)는
infra 영역에 둬야 한다.
- Q.가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.

## 4.3 매핑 구현

### 엔티티와 밸류 기본 매핑 구현
- 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정한다.
- 밸류는 @Embeddable로 매핑하고 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다.

### 필드 접근 방식
- 엔티티 프로퍼티에 get/set 메소드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다.
- 특히 set 메소드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 꺠는 원인이 될 수 있다.
- 엔티티는 의도가 잘 드러나는 기능을 제공해야 한다. setState 보다는 cancel 메소드가 도메인을 더 잘표현하고 
setShippingInfo 보다는 changeShippingInfo가 의도를 더 잘 나타낸다.

### AttributeConverter를 이용한 매핑 처리
- 밸류 타입의 여러 프로퍼티를 DB의 한 개 컬럼에 매핑해야 할 때 AttributeConverter를 사용할 수 있다.

### 별도 테이블에 저장하는 밸류매핑
- 애그리거트에서 루트 엔티티를 제외한 나머지 구성 요소는 대부분 밸류이다.
- 단지 별도 테이블에 데이터를 저장한다고 엔티티는 아니다. 예를 들어 OrderLine을 별도 테이블에 저장하지만 OrderLine 자체는 엔티티가 아니라 밸류다.
- 애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지 확인하는 것이다. ID 컬럼이란 식별자를 가지고 있다 해서
엔티티라고 착각하면 안 된다. 이 때의 ID는 애그리거트 루트와 연결하기 위함이다.

### ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑
- 애그리거트 간 집합 연관은 성능 상의 이유로 피하는게 좋은데, 요구사항을 구현하기 위해 집합 연관을 사용하는게 유리하다면
ID 참조를 이용한 단방향 집합 연관을 적용할 수 있다.

### 4.4 애그리거트 로딩 전략
- 즉시 로딩으로 애그리거트에 속한 모든 객체를 로딩한다는 것은 항상 좋은 것은 아니다. 특히 컬렉션에 대해 EAGER르 설정하면 오히려 문제가 될 수 있다.
- 조회 성능 때문에 즉시 로딩 방식을 사용하지만 이렇게 조회되는 연관 객체들이 많아진다면 성능(실행 빈도, 지연 로딩시 실행 속도)을 검토해야 한다.
- 애그리거트는 개념적으로 하나여야 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 모든 객체를 모두 로딩해야 하는 것은 아니다.
애그리거트가 완전해야 하나는 두 가지 이유는 
  - 상태를 변경하는 기능을 실행할 때 에그리거트 상태가 완전해야 하고
  - 애그리거트의 정보를 보여줄 때 필요하다.
- 이 중 두번째 데이터를 보여주는 측면에서는 별도의 조회 전용 기능과 모델을 구현하는 방식을 사용하는게 유리하기에 애그리거트의 완전한 로딩은
상태 변경과 더 관련이 있다. 상태 변경을 위해 애그리거트를 완전히 로딩할 필요는 없으며 상태를 변경하기 위해 필요한 구성요소만 로딩해도 된다.
- 지연 로딩은 동작방식이 항상 동일한 반면에 즉시 로딩은 Entity, Embeddable, JPA 프로바이더에 따라 달라질 수 있다. 물론 지연 로딩은
즉시 로딩보다 쿼리 실행 횟수가 많아지기 때문에 애그리거트에 맞게 즉시로딩과 지연로딩을 선택해야 한다.

### 4.5 애그리거트의 영속성 전파
- 애그리거트가 완전한 상태여야 한다는 것은 저장하고 삭제할 때도 하나로 처리되어야 한다.
- @Embeddable 매핑 타입은 함께 저장되고 삭제되므로 cascade 옵션을 설정하지 않아도 된다.
- 반면에 애그리거트에 속한 @Entity 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제시에 동시에 처리되도록 설정한다.

## 4.6 식별자 생성 기능
- 식별자 생성 규칙이 있다면 엔티티를 생성할 때 별도 서비스로 식별자 생성 기능을 분리해야 한다.
- 식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 도메인 서비스를 두고, Service layer에서 도메인 서비스를 이용해 식별자를 구하고 엔티티를 생성한다.
- 도메인 서비스 말고 또 다른 장소가 있다면 리포지터리이다. 아래와 같이 메서드를 추가한 뒤 구현 클래스에서 알맞게 구현하면 된다.
```java
public interface ProductRepository {
    // 식별자 생성 메소드
    ProductId nextId();
}
```

