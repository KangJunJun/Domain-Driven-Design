# Chapter 6 - 응용 서비스와 표현 영역

## 6.1 표현 영역과 응용 영역

도메인 영역만 잘 구현하면 제대로 된 소프트웨어를 만들지 못한다.  
도메인이 제 기능을 하려면 사용자와 도메인을 연결해 주는 매개체(표현영역과 응용영역)가 필요하다.

* 표현 영역  
  사용자의 요청을 해석한다.  
  요청받은 표현 영역은 URL, 요청 파라미터, 쿠키, 헤더 등을 이용해서 사용자가 실행하고 싶은 기능을 판별하고 응용 서비스를 실행한다.
* 응용 영역  
  실제 사용자가 원하는 기능을 제공.  
  응용 서비스의 메서드가 요구하는 파라미터와 표현 영역이 사용자로부터 전달받은 데이터는 형식이 일치하지 않기 때문에 변환작업을 한다.

응용 서비스를 실행한 뒤에 표현 영역은 실행 결과를 사용자에게 알맞는 형식으로 응답한다. (HTML, JSON 등)  
사용자와 상호작용은 표현 영역이 처리하기 때문에, 응용 서비스는 표현 영역에 의존하지 않는다.  
즉, 응용영역은 표현영역 보다 고수준 정책이므로 응용영역은 표현형역에 의존해서는 안된다.

## 6.2 응용 서비스의 역할

응용 서비스는 사용자의 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용한다.  
응용 서비스는 주로 도메인 객체간 흐름을 제어한다.

````java
public class someService() {
   public Result doSomeFunc(SomeReq req) {
      // 리포자터리에서 애그리거트를 구한다.
      SomeAgg agg = someAggRepository.findById(req.getId());
      checkNull(agg);
      // 에그리거트의 도메인 기능을 실행한다.
      agg.doFunc(req.getValue());
      // 결과를 리턴한다.
      return createSuccessResult(agg);
   }

   public Result doSomeCreation(CreateSomeReq req) {
      // 데이터 중복 등 유효성 검사를 한다.
      validate(req);
      // 애그리거트를 생성한다.
      SomeAgg newAgg = createSome(req);
      //리포지터리에 애그리거트를 저장한다.
      someAggRepository.save(newAgg);
      // 결과를 리턴한다.
      return createSuccessResult(newAgg);
   }
}
````

응용서비스가 복잡하다면 도메인 로직의 일부를 구현하고 있을 가능성이 높다.

응용서비스는 트랜잭션 처리와 접근 제어, 이벤트 처리도 담당한다.

### 6.2.1 도메인 로직 넣지 않기

만약 도메인 로직이 응용영역에 위치한다면 다음과 같은 문제를 야기한다.

1. 코드의 응집성이 떨어진다.  
   응용영역에 위치한 코드로 인해 해당 도메인 관련 코드를 분석할 때 도메인영역내의 로직뿐만이 아니라 여기저기 흩어져있는 응용영역도 분석 해야한다.
2. 중복 코드 발생  
   도메인관련 코드는 도메인이 책임을 가지고 구현하고, 퍼블릭 메서드로 외부에 제공되어야한다.  
   그리고 응용 영역에서는 이 퍼블릭 메서드를 사용하기위해 단순히 메시지만 전송하면 된다.  
   만일 도메인 로직이 응용영역에 위치해 응용영역에서 구현한다면 같은 여러 응용 영역 내 중복되는 도메인로직이 존재할 가능성이 높다.

## 6.3 응용 서비스의 구현
응용서비스는 파사드 패턴과 같은 역할을 한다.

Facade 패턴?  "하위 시스템을 보다 쉽게 사용할 수 있게 해주는 고급 인터페이스"  
구조 패턴(Structural Patterns)에 속하며 구조 패턴이란 '클라스나 객체를 조합하여 더 큰 구조를 만드는' 패턴

### 6.3.1 응용 서비스의 크기

응용 서비스 구현 방식 두 가지.
1. 한 응용 서비스 클래스에 도메인의 모든 기능 구현하기
   - 기능 코드가 한 클래스에 있어서 중복 제거 장점이 있다.
   - 하나의 서비스 클래스가 너무 커질 수 있다는 단점이 있다.
   - 너무 커지면 복잡도가 높아지고 관련 없는 코드가 뒤섞일 위험이 있다.
2. 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
   - 여러 클래스에 중복 코드를 구현할 가능성이 있다. --> 유틸 클래스로 관리

한 도메인과 관련된 기능을 하나의 응용 서비스 클래스에 모두 담는 것 보다 **구분되는 기능을 별도의 서비스 클래스로 구현하길 추천**한다고 한다.

### 6.3.2 응용 서비스의 인터페이스와 클래스

응용 서비스를 구현할 때 인터페이스가 필요한가?  
응용 서비스는 보통 런타임에 구현 클래스를 교체하거나 하나의 응용 서비스의 구현 클래스가 2개 이상인 경우는 드물다.

인터페이스가 불필요한 상황에 사용한다면 오히려 소스파일 증가, 간접 참조 증가로 인해 구조가 복잡해진다.  
TDD 로 컨트롤러를 개발하는 경우 응용서비스 부분을 인터페이스로 작성 해두면 응용서비스의 구현 없이 컨트롤러 구현이 가능해진다.  
응용서비스를 TDD로 개발하는 경우 인터페이스를 만들어야 하지만 Mockito 같은 테스트 도구를 사용하면 인터페이스가 필요 없다.

### 6.3.3 메서드 파라미터와 값 리턴

응용 서비스가 제공하는 메서드는 필요한 파라미터를 낱개로 받을 수도 있고 별도 클래스를 만들어(DTO) 전달할 수 있다.  
스프링 MVC 같은 웹프레임워크는 요청 파라미터를 자바 객체로 변화하는 기능을 제공하므로 파라미터가 2개 이상인 경우 별도 클래스를 사용하는 것이 편리하다.

표현 영역에서 서비스의 리턴값을 필요로 한다면 응용 서비스 메서드에서 필요한 데이터를 리턴한다.  
이때 필요한 값만 리턴할 수도 있고, 애그리거트 객체를 그대로 리턴할 수도 있다.  
애그리거트를 리턴하는 경우 표현 영역에서도 도메인 로직을 실행 할수 있게 되므로, 로직이 분산되고 코드의 응집도가 낮아지게 된다.

### 6.3.4 표현 영역에 의존하지 않기

주의 - 표현 영역과 관련된 타입을 응용 서비스에서 사용하면 안된다.

응용 서비스에서 표현 영역에 대한 의존이 발생하면 서비스 단위테스트가 어려워진다.  
표현 영역의 구현이 변경되면 응용 서비스도 변경해야 한다.  
쿠키 같은 표현 영역의 상태를 응용 서비스에서 변경해 버리면 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 이해하기 어려워진다. - 응집도가 깨진다.

결론 : 표현영역의 구현 기술은 표현영역에서만 사용하자.

### 6.3.5 트랜잭션 처리

영속성 데이터의 일관된 상태를 위해 사용해야 한다.  
스프링과 같은 프레임워크를 사용하면 @Transactional 등 제공되는 트랜잭션 관리 기능을 이용해서 손쉽게 트랜잭션을 처리할 수 있다.

스프링의 기본 동작은 @Transactional 이 적용된 메서드에서 RuntimeException이 발생하면 rollback하고 그렇지 않으면 commit.

## 6.4 표현 영역

표현 영역의 책임
* 사용자가 시스템을 사용할 수 있는 (화면) 흐름을 제공하고 제어한다.
   * ex) 게시글 쓰기를 표현 영역에 요청하면 게시글을 작성할 수 있는 폼 화면을 응답으로 제공한다.
* 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
   * 응용 서비스의 실행 결과를 사용자에게 알맞은 형식으로 제공하는 것도 표현 영역의 몫이다.
   * 뷰를 반환하거나 특정 형식의 메시지 body를 반환한다.
* 사용자의 세션을 관리한다.
   * 웹의 경우 쿠키나 서버의 세션을 이용해 사용자의 연결 상태를 관리한다.
   * 세션 관리는 권한 검사와도 연결된다.

## 6.5 값 검증

값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다.
* 원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리한다.
* 표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 값을 다시 입력받아야 한다.

사용자가 폼을 입력하고 전송하면 첫번째에 예외를 발생시킬 경우 나머지 항목은 검사하지 않으며, 이 경우 검증 작업을 오입력한 필드 별로 반복하게 된다.  
이런 사용자 불편을 해소하기 위해 에러 코드를 모아 하나의 익셉션으로 발생 시키는 방법도 있다.  
(ex. 스프링의 ValidationError 인터페이스)

응용 서비스를 사용하는 표현 영역 코드가 한 곳에 있다면 구현의 편리함을 위해 다음과 같이 역할을 나눠 검증을 수행할 수 있다.
* 표현 영역 : 필수 값, 값의 형식, 범위 등을 검증한다.
* 응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류를 검증한다.

응용 서비스에서 검증의 엄격함이 어느 수준까지 필요하냐에 따라 나눠서 검증하는 방식보다 응용서비스 한 곳에서 검증하는게 더 좋을 수도 있다.

## 6.6 권한 검사

개발할 시스템마다 권한의 복잡도가 다르다.  
이런 다양한 상황을 충족하기 위해 스프링 시큐리티 같은 프레임워크가 있다.  
유연한 만큼 복잡해서 이해가 부족하다면 직접 구현하는게 유지보수에 유리할 수도 있다.

보통 표현 영역, 응용 서비스, 도메인 세 곳에서 권한 검사를 수행할 수 있다.

* 표현 영역 검사
   * 기본적으로 인증된 사용자인지 아닌지 여부를 검사
   * 접근 제어를 하기에 좋은 위치가 서블릿 필터이다.
*  응용 서비스 검사
   * URL 만으로 접근 제어를 할 수 없는 경우 -> 이게 꼭 응용 서비스에서 검사를 해야한 다는 의미는 아님
   * 스프링 시큐리티는 AOP를 활용해서 @PreAuthorize() 으로 서비스 메서드에 대한 권한 검사를 할 수 있는 기능을 제공 한다.
* 도메인 검사
   * 특정 애그리거트를 먼저 로딩 한 후 검사 로직이 실행되야 함
   * 응용 서비스의 메서드 수준에서 권한 검사를 할 수 없기 때문에 직접 권한 검사 로직을 구현해야 한다.


## 6.7 조회 전용 기능과 응용 서비스

서비스에서 수행하는 추가적인 로직이 없고 조회 전용이라 트랜잭션이 필요하지 않을 경우..?

````java
public class OrderListService {
  public List<OrderView> getOrderList(String ordererId) {
    return orderViewDao.selectByOrderer(ordererId);
  }
}
````

어색한 상황이지만 표현 영역에서 바로 조회 전용 기능을 사용해도 문제가 없다고 한다.