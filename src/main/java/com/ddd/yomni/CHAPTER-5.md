# Chapter 5. 스프링 데이터 JPA를 이용한 조회 기능

---

<!-- TOC -->
* [Chapter 5. 스프링 데이터 JPA를 이용한 조회 기능](#chapter-5-스프링-데이터-jpa를-이용한-조회-기능)
  * [5.1 시작에 앞서](#51-시작에-앞서)
  * [5.2 검색을 위한 스펙](#52-검색을-위한-스펙)
  * [5.3 스프링 데이터 JPA를 이용한 스펙 구현](#53-스프링-데이터-jpa를-이용한-스펙-구현)
  * [5.4 리포지터리/DAO에서 스펙 사용하기](#54-리포지터리dao에서-스펙-사용하기)
  * [5.5 스펙 조합](#55-스펙-조합)
  * [5.6 정렬 지정하기](#56-정렬-지정하기)
  * [5.7 페이징 처리하기](#57-페이징-처리하기)
  * [5.8 스펙 조합을 위한 스펙 빌더 클래스](#58-스펙-조합을-위한-스펙-빌더-클래스)
  * [5.9 동적 인스턴스 생성](#59-동적-인스턴스-생성)
  * [5.10 하이버네이트 @Subselect 사용](#510-하이버네이트-subselect-사용)
  * [생각해보자](#생각해보자)
<!-- TOC -->

---


## 5.1 시작에 앞서

- [CQRS(Command Query Responsibility Segregation)](https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cqrs) : 명령 모델과 조회 모델을 분리하는 패턴
  - 명령(Command) 모델 : 상태를 변경하는 기능을 구현할 때 사용  
    - 회원가입, 암호 변경, 주문 취소 기능을 구현할 때
    - 주로 엔티티, 애그리거트, 리포지터리 등이 주로 사용됨
  - 조회(Query) 모델 : 데이터를 조회하는 기능을 구현할 때 사용   
    - 주문 목록, 주문 상세 기능 구현할 때
    - 반면, 정렬, 페이징, 검색 조건 지정 등과 같은 기능은 주문 목록, 상품 상세
- 따라서, 책에서는 예제 코드로 리포지터리(도메인 모델에 속한)와 DAO(데이터 접근을 의미하는)라는 이름을 혼용해서 사용
 
> - CQRS 장점
>    - 성능, 확장성 및 보안을 최대화 할 수 있음 
>    - 업데이트 명령이 도메인 수준에서 병합 충돌을 일으키지 않도록 할 수 있음
>  - CQRS 단점
>    - 비교적 규모가 작은 서비스엔 배보다 배꼽이 더 큰 격
> 
> 질문) DB에 조회하는 시점에 엔티티로 조회하고, 최종 result 로는 DTO로 반환해준다면, 이건 CQRS일까요? 

---

## 5.2 검색을 위한 스펙

- 조건을 위한 별도 인터페이스 (Specification)

---

## 5.3 스프링 데이터 JPA를 이용한 스펙 구현

- Criteria 사용을 위한 Specification 인터페이스

---

## 5.4 리포지터리 / DAO에서 스펙 사용하기

- `findAll(Specification<OrderSummary> spec)`과 같은 방식으로 스펙을 충족하는 엔티티를 검색할 수 있다. 

---

## 5.5 스펙 조합

- and / or 를 통해 스펙을 조합할 수 있다.

---

## 5.6 정렬 지정하기

- **메서드 이름에 OrderBy를 사용해서 정렬** 기준 지정
- Sort를 인자로 전달

---

## 5.7 페이징 처리하기

- Pageable 타입 파라미터를 사용하여 페이징을 자동으로 처리

---

## 5.8 스펙 조합을 위한 스펙 빌더 클래스

- 스펙빌더 코드(`and()`, `ifHasText()`, `ifTrue()`)를 통해 코드 가독성을 높이고 구조를 단순화 한다.

---

## 5.9 동적 인스턴스 생성

- 조회 전용 모델(API Response 객체)을 만드는 이유는 **표현 영역을 통해 사용자에게 데이터를 보여주기 위함**
  - 동적 인스턴스는 JPQL을 그대로 사용하므로 객체 기준으로 쿼리를 작성가능
  - 즉시 / 지연 로딩과 같은 고민 없이 데이터 조회 가능

---

## 5.10 하이버네이트 @Subselect 사용

- 하이버네이트는 `@Subselect`를 사용해서 쿼리 결과를 `@Entity`로 매핑할 수 있는 유용한 기능을 제공한다.
- Entity 로 받는다는 것은, 영속성 컨테이너의 관리 대상이 되므로 변경사항이 발생하면 update 시점에 유의해야 함
- 따라서, 사이드 이펙트를 최소화 하려면 Native SQL query를 사용하거나 마이바티스 등으로 **영속성 컨테이너**의 영향을 받지 않도록 구현해야 한다.

---

## 생각해보자

- DDD 관점에서 스프링 데이터 JPA를 사용해서 조회 기능을 구현하는 좋은 방법들에 대해서 알 수 있어서 좋은 챕터였습니다.
- 하지만, Criteria 위주의 설명이 아쉬웠습니다. (QueryDSL 은 2010년도에 개발되던 기술, 책의 최초 출간일은 2016년 임을 감안해도...)
- JPQL 레벨에서 Response 객체(표현계층)를 불러오는 것은 의존성이 어떻게 될까요? (객체간 의존 관계가 아니라서 상관이 없나..)

---