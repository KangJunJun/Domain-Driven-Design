# Chapter 3. 애그리거트

<!-- TOC -->
* [Chapter 3. 애그리거트](#chapter-3-애그리거트)
  * [3.1 애그리거트](#31-애그리거트)
  * [3.2 애그리거트 루트](#32-애그리거트-루트)
    * [3.2.1 도메인 규칙과 일관성](#321-도메인-규칙과-일관성)
    * [3.2.2 애그리거트 루트의 기능 구현](#322-애그리거트-루트의-기능-구현)
    * [3.2.3 트랜잭션 범위](#323-트랜잭션-범위)
  * [3.3 리포지터리와 애그리거트](#33-리포지터리와-애그리거트)
  * [3.4 ID를 이용한 애그리거트 참조](#34-id를-이용한-애그리거트-참조)
    * [3.4.1 ID를 이용한 참조와 조회 성능](#341-id를-이용한-참조와-조회-성능)
  * [3.5 애그리거트 간 집합 연관](#35-애그리거트-간-집합-연관)
  * [3.6 애그리거트를 팩토리로 사용하기](#36-애그리거트를-팩토리로-사용하기)
  * [생각해봅시다..!](#생각해봅시다-)
<!-- TOC -->

---

## 3.1 애그리거트

애그리거트란? 
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만든 것
- 상위 수준에서 모델을 조망하는 방법

장점
- 모델 간의 관계를 파악하기가 용이
- 코드를 변경하거나 확장할 때 큰그림 차원에서 유지보수하기 편한 방법으로 개선 가능

단점(개인적 생각)
- 요구사항 분석이 제대로 이루어지지 않은 경우, 오히려 생산성을 떨어트리는 요인이 될 수도 있을 것 같음

어떻게 묶나요?(경계 설정)
- 동일한 라이프 사이클  
  (ex : Order를 생성하려면 OrderLine, Orderer, ShippingInfo, ... 같이 생성해야 함)
- 요구사항에 따라 같이 변경되는 빈도가 높은 객체끼리  
  --> 사용자 요구사항에 따라 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높음

주의
- 객체 간 의존성에 따라 애그리거트로 생각하는 경향이 있는데 이는 좋지 않음  
- 상품(Product) 와 리뷰(Review)의 관계  
  --> '상품이 리뷰를 갖는다.' 라는 의존성(Maybe association)이 있지만 애그리거트에서는 서로 분리된다.
  - 상품은 상품 담당자에 의해 변경된다
  - 리뷰는 고객에 의해 변경된다.

---

## 3.2 애그리거트 루트

애그리거트 루트란?
- 애그리거트는 여러 객체로 구성되므로 한 객체만 상태가 정상이면 안됨
- 애그리거트에 속한 모든 객체가 정상 상태를 유지해야 한다.
- 누가? --> 애그리거트 루트 **엔티티**

### 3.2.1 도메인 규칙과 일관성

애그리거트 루트의 핵심 역할은 **애그리거트의 일관성이 깨지지 않도록 하는 것**
- 구매할 상품의 개수를 변경하면, 주문 상세정보(OrderLine) 뿐만 아니라 주문(Order)의 전체수량도 변경되어야 한다.
- 당연하게도, 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하는 것은 안됨
  - 오직 애그리거트 루트에 의해서만 애그리거트 내부 객체가 변경되어야 한다.
  - 밸류 타입은 `불변`, `No setter or No public setter` 를 준수

### 3.2.2 애그리거트 루트의 기능 구현


### 3.2.3 트랜잭션 범위



---

## 3.3 리포지터리와 애그리거트

---

## 3.4 ID를 이용한 애그리거트 참조

### 3.4.1 ID를 이용한 참조와 조회 성능

---

## 3.5 애그리거트 간 집합 연관

---

## 3.6 애그리거트를 팩토리로 사용하기

---

## 생각해봅시다..!


---