# Chapter 3. 애그리거트

<!-- TOC -->
* [Chapter 3. 애그리거트](#chapter-3-애그리거트)
  * [3.1 애그리거트](#31-애그리거트)
  * [3.2 애그리거트 루트](#32-애그리거트-루트)
    * [3.2.1 도메인 규칙과 일관성](#321-도메인-규칙과-일관성)
    * [3.2.2 애그리거트 루트의 기능 구현](#322-애그리거트-루트의-기능-구현)
    * [3.2.3 트랜잭션 범위](#323-트랜잭션-범위)
  * [3.3 리포지터리와 애그리거트](#33-리포지터리와-애그리거트)
  * [3.4 ID를 이용한 애그리거트 참조](#34-id를-이용한-애그리거트-참조)
    * [3.4.1 ID를 이용한 참조와 조회 성능](#341-id를-이용한-참조와-조회-성능)
  * [3.5 애그리거트 간 집합 연관](#35-애그리거트-간-집합-연관)
  * [3.6 애그리거트를 팩토리로 사용하기](#36-애그리거트를-팩토리로-사용하기)
  * [생각해봅시다..!](#생각해봅시다-)
<!-- TOC -->

---

## 3.1 애그리거트

애그리거트란?
- **관련 객체을 묶은 군집**
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만든 것
- 상위 수준에서 모델을 조망하는 방법

장점
- 모델 간의 관계를 파악하기가 용이
- 코드를 변경하거나 확장할 때 큰그림 차원에서 유지보수하기 편한 방법으로 개선 가능

단점(개인적 생각)
- 요구사항 분석이 제대로 이루어지지 않은 경우, 오히려 생산성을 떨어트리는 요인이 될 수도 있을 것 같음

어떻게 묶나요?(경계 설정)
- 동일한 라이프 사이클  
  (ex : Order를 생성하려면 OrderLine, Orderer, ShippingInfo, ... 같이 생성해야 함)
- 요구사항에 따라 같이 변경되는 빈도가 높은 객체끼리  
  --> 사용자 요구사항에 따라 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높음

주의
- 객체 간 의존성에 따라 애그리거트로 생각하는 경향이 있는데 이는 좋지 않음  
- 상품(Product) 와 리뷰(Review)의 관계  
  --> '상품이 리뷰를 갖는다.' 라는 의존성(Maybe association)이 있지만 애그리거트에서는 서로 분리된다.
  - 상품은 상품 담당자에 의해 변경된다
  - 리뷰는 고객에 의해 변경된다.

---

## 3.2 애그리거트 루트

애그리거트 루트란?
- 애그리거트는 여러 객체로 구성되므로 한 객체만 상태가 정상이면 안됨
- 애그리거트에 속한 모든 객체가 정상 상태를 유지해야 한다.
- 누가? --> 애그리거트 루트 **엔티티**

### 3.2.1 도메인 규칙과 일관성

애그리거트 루트의 핵심 역할은 **애그리거트의 일관성이 깨지지 않도록 하는 것**
- 구매할 상품의 개수를 변경하면, 주문 상세정보(OrderLine) 뿐만 아니라 주문(Order)의 전체수량도 변경되어야 한다.
- 당연하게도, 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하는 것은 안됨
  - 오직 애그리거트 루트에 의해서만 애그리거트 내부 객체가 변경되어야 한다.
  - 밸류 타입은 `불변`, `No setter or No public setter` 를 준수

### 3.2.2 애그리거트 루트의 기능 구현

애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
- Order는 총 주문 금액을 구하기 위해 OrderLine 목록을 사용한다.
- Member 애그리거트 루트는 암호를 변경하기 위해 Password 객체에 암호가 일치하는 지 확인 **요청**
- 최대한 불변으로 구현, 만약 팀 표준이나 구현 기술의 제약으로 불가능 하다면 protected 로 범위 한정

### 3.2.3 트랜잭션 범위

**_트랜잭션 범위는 작을수록 좋다_**

한 트랜잭션 내에서
- 1개 테이블 수정 vs 3개 테이블 수정 --> 당연히 1개 테이블만 수정하는 것이 성능면에서 더 뛰어나다
- 동시간 대 더 많은 테이블에 lock이 걸리기 때문에, 처리량이 떨어짐

`트랜잭션 : 애그리거트 수정 대상 = 1 : 1` 권장 
- 애그리거트 수정 대상이 많아질 수록 트랜잭션 충돌 발생 가능성이 높아진다.
  - 예를 들어) 배송지 정보를 변경하면서 동시에 배송지 정보를 회원의 주소로 설정하는 기능이 있다면?  
    **주문 애그리거트에서 회원 애그리거트의 상태를 변경하면 안된다.**

`트랜잭션 : 애그리거트 수정 대상 = 1 : 다` 비권장. 하지만?
- 팀 표준 : 사용자 유스케이스에 따라 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우
- 기술 제약 : 이벤트 방식을 도입할 수 없는 경우, 일관성유지를 위해 1 : 다 수정해야 함 
- UI 구현의 편리 : 운영자는 관리가 편해야 한다 --> 조금 더 포괄적인 권한 


> 질문) 그럼 위의 예시처럼 상품 주문 시, 배송지 정보를 변경하면서 회원의 주소로 설정해야 한다면 어떻게 처리해야 할까요?  
> - 예상 시나리오 1) 응용 서비스에서 두 애그리거트를 수정하도록 구현한다(책에 있는 내용)
> - 예상 시나리오 2) 배송지 정보를 변경하면, 이를 회원 애그리거트에 MQ 등으로 정보 변경 요청을 한다.

---

## 3.3 리포지터리와 애그리거트

이론적인 차원에서 애그리거트는 완전한 한 개의 도메인 모델을 표현하므로 `애그리거트 : 리포지터리 = 1 : 1` 권장
- Order 와 OrderLine 각각 리포지터리를 만들지는 않는다. (Order 리포지터리만 생성)
- 리포지터리는 보통 다음 두 메서드를 기본으로 제공
  - save : 애그리거트 저장
  - findById : ID로 애그리거트를 구함
- 리포지터리는 애그리거트 전체를 저장소에 영속화 해야 한다.

> 질문) JPA 가 아닌 기술을 사용하는 경우 애그리거트 구현이 어떻게 영향을 받을까요?

---

## 3.4 ID를 이용한 애그리거트 참조
객체간 의존성이 있는 것처럼 애그리거트도 다른 애그리거트에 의존한다.  
애그리거트의 관리 주체는 애그리거트 루트이므로 애그리거트 간 의존 관계는 다른 애그리거트 루트를 의존한다고 볼 수 있다. 

다른 애그리거트를 직접 참조하면?

장점
- 필드를 이용해 다른 애그리거트를 쉽게 참조

단점 
- 편한 탐색의 오용(다른 애그리거트의 상태를 변경하기가 쉽다)
- 성능에 대한 고민(LAZY vs EAGER)
- 확장 어려움(도메인마다 DBMS를 따로 가져가려한다면? --> 상상만으로도 고통스러운 일..)

결론(직접참조 단점을 다 반대로 생각해보면 된다.)
- **애그리거트 간 의존관계는 ID에 의한 참조를 이용**하는 것이 좋다.
  - 애그리거트 간 경계가 명확해짐 (애그리거트의 응집도도 높아짐)
  - 성능에 대한 고민 할 필요 없음
  - 확장 하기 쉽다

> 질문) 책에서는 MemberId 라는 별도의 클래스로 정의한 거 같은데  
> 이런 경우 장/단점이 있을 것 같아요  
> - 장점 : 엔티티와 밸류에서 밸류타입의 장점(기능을 직접 제어한다던가, ...)
> - 단점 : 객체가 과도하게 많아진다.
> 
> 예상되는 정도는 이런점인데, 혹시 **MemberId 라는 클래스를 정의하면서까지 단점을 상쇄시킬만한 이점을 누리는지 궁금합니다..**

### 3.4.1 ID를 이용한 참조와 조회 성능

ID를 이용한 참조에서도 N+1 문제를 야기할 수 있다.  

해결방법
1. Join을 이용해 한번의 쿼리로 조회전용 쿼리를 사용한다. (JPQL)
2. 쿼리가 복잡하거나, SQL에 특화된 기능을 사용해야 한다면? (마이바티스 등등)

만약 애그리거트마다 다른 저장소를 사용한다면?  
--> 한번의 쿼리로 관련 애그리거트를 조회할 수 없다.
- **캐시 적용**
- **조회전용 저장소**를 별도 구성
  - JPA에서 조회전용 쿼리를 실행하는 방법은 5장에 위임
  - 11장에서는 CQRS (명령 모델과 조회 전용 모델을 분리해서 구현하는 패턴)에 대해 다룬다

---

## 3.5 애그리거트 간 집합 연관

애그리거트 간 관계가 `1 : N` 혹은 `M : N` 이라면?  

`N : 1` 의 경우 `상품 : 카테고리` 로 가정
- Product(N) 진형에서 Category 의 의존성만 남긴다.
- 이 때, 애그리거트 간 의존관계 이기 때문에 ID에 의한 참조로 설계한다.

`M : N` 의 경우 `카테고리 : 상품` 로 가정(상품이 여러 카테고리로 분류될 수 있음)
- Product(N) 진형에서 Category 의 의존성만 남긴다.
- 이 때, `ID에 의한 참조`+ `Collection 으로 관리` 하도록 설계한다

결론
- 단방향으로 설계
- ID에 의한 참조
- (필요한 경우) Collection 으로 관리

추가 학습 키워드
- JPA의 [@ElementCollection](https://prohannah.tistory.com/133)
- 성능 관련된 내용은 4장으로 위임
> - @ElementCollection:
>   - 연관된 부모 Entity 하나에만 연관되어 관리된다. (부모 Entity와 독립적으로 사용 X)
>   - 항상 부모와 함께 저장되고 삭제되므로 cascade 옵션은 제공하지 않는다. (cascade = ALL 인 셈)
>   - 부모 Entity Id와 추가 컬럼(basic or embedded 타입)으로 구성된다. 
>   - 기본적으로 식별자 개념이 없으므로 컬렉션 값 변경 시, 전체 삭제 후 새로 추가한다. 
> - @Entity 연관 (@OneToMany / @ManyToMany):
>   - 다른 Entity에 의해 관리될 수도 있다. 
>   - join table이나 컬럼은 보통 ID만으로 연관을 맺는다.

---

## 3.6 애그리거트를 팩토리로 사용하기
팩토리란 `객체 생성에 관한 책임이 있는 객체`로 이해.  

애그리거트는 관련 객체를 하나로 묶은 군집 이기 때문에, 애그리거트 내에 있는 관련 객체끼리 생성주기를 같이 한다.  
따라서, 객체 생성에 관한 것은 관련 객체들 사이의 의존관계나 요구사항에따라 정의되는 것이 바람직하다.  
방법으로는
- 별도의 도메인 서비스
- 팩토리 클래스
- **애그리거트 내 관련 객체끼리의 생성**
  - 예를 들면, '특정 가게의 상태를 보고 상품을 등록(save)할 지 결정된다.' 라는 요구사항이 있다면?
- 특히 객체 생성의 책임이 까다롭다면, 도메인 내 로직 + 팩토리 클래스 로 설계도 가능

> 질문) 디자인 패턴에 관한 고찰
> - 애그리거트를 팩토리로 사용하기에서 제안하는 코드에서  
>   Store 를 Product 의 심플 팩토리로 볼 수 있습니다.
> - 이 코드에서 `static`이 쓰이지 않은 것을 볼 수 있는데, 잘못된 건가요?..
> 
> 개인적인 생각) 팩토리 패턴의 출현 배경에는 '객체 생성에 관한 책임을 별도로 가지고 있는 객체 설계'
---

## 생각해봅시다..!
- 만약 JPA만 학습 후, DDD를 공부했다면, ID에 의한 참조에서 많은 혼란이 있었을 것 같습니다.  
  조영호님 우아한테크세미나의 의존성과 과련된 부분을 이해한 후 ID에 의한 참조를 보니 편안하네요~

## 도움!!!
- 연봉협상에 관한 노하우가 있으시면 공유좀 부탁드립니다ㅠㅠ

---