# 애그리거트 

## 도메인 모델링이란?
- 도메인 모델링이란 비즈니스 로직을 표현하는 것이다. 
- 비즈니스 로직을 모델링하면 이해관계자들 사이에서 커뮤니케이션과 작업이 용이해지고, 유지보수가 쉬워진다.

## 도메인 모델링의 구성요소
- 엔티티: 식별자를 가진 객체, 고유하게 식별 가능하며 생명 주기를 갖는다.
- 밸류: 엔티티에 속하는 객체로 고유한 식별자를 갖지 않으며, 엔티티 생명주기에 종속된다.
- 애그리게잇: 관련된 엔티티와 밸류의 모음, 하나의 루트 엔티티와 그 엔티티에 속한 밸류들로 구성된다.
- 리포지토리: 애그리게잇의 영속화와 조회를 담당한다.
- 서비스: 특정 애그리게잇에 속하지 않는 도메인 로직을 처리한다.
- 도메인 이벤트: 도메인에서 발생하는 중요한 사건, 도메인 모델의 상태 변경 등을 나타낸다.
- 무결성 규칙: 도메인에서 지켜져야 하는 제약 조건을 의미한다.
## 도메인 모델링의 구현
- 도메인 모델링의 구현은 객체지향 언어를 이용하는 것이 적합하다. 
- 적절한 패턴과 객체지향 설계 원칙을 사용하면 도메인 모델링을 효과적으로 구현할 수 있다.

이상 ChatGPT에게 문의한 내용이다.
---

## 애그리거트를 나누는 기준 ?
- 이 책에서 설명하는 애그리거트 나누는 기준은 `생명주기`, `데이터발생주체` 위주로 이야기하고 있다.
- 주문이라는 도메인은 주문한정보, 회원의 배송정보 등이 필요하여 Order의 애그리거트엔 OrderLine, ShippingInfo가 포함된다.
- 다만 흥미로운 점은 `상품`과 `리뷰`를 분리한 점인데, 비슷한 유형으로 보이지만,    
  `생성주기`가 상이하며, 데이터 생성하는 주체가 `상품담당자`와 `상품구매자`로 상이하여 다른 애그리거트로 묶었다.

## 어떻게하면 리스크를 낮추고 애그리거트를 구현할까 ?
- `불볍객체`를 활용하는 것을 강조
- 다른 애그리거트의 데이터를 변경하는 행위가 필욜할 때 직접적으로 변경하는 것이 아닌, `중간 응용서비스`를 구성해 처리(의존성 역전과 유사해보임)
- 이 책에선 다른 애그리거트를 직접 참조하는 것이 아닌 `Id(Key)` 값으로 조회하는 것을 추천
- Order 엔티티에서 Member member 와 같이 직접 참조를 한다면, member를 Order 애그리거트에서 수정하는 사항이 발생할 수 있다.

## 성능이슈(N+1, 1-N 연관관계)와 확장성
- 무조건 답은 없지만 대체로 1-N 연관관계보다는 N-1 연관관계 매핑을 하는 설계를 추천하고 있다.
  - 1-N은 한개의 엔티티가 여러개의 엔티티를 참조하는 것을 로딩하지만, N-1은 다수의 엔티티에서 하나의 엔티티만 참조해서 가져올 수 있다.
- N+1 문제는 지연로딩, 즉시로딩으로 가이드를 주는데, 보고서 같은 케이스는 즉시로딩, 이외는 JPQL 활용하는 방법으로 가이드하고 있다.
- 확장성 또한 직접적을 참조하는 것이 아닌 ID로 참조하는 것으로 확장성을 확보할 수 있다.
  - 이 책에서 말하는 확장성은 도메인영역에 따라 NoSQL, MySQL등 다르게 사용할 수 있는데,
  - 직접적으로 참조해서 데이터를 변경하면 그에 따른 Repository도 구성해야하기 떄문에
    - Service 레이어에서 참조 가능하다.
  - ID로 참조(간접적으로), 변경에 대한 메시지를 호출해서 처리하면 확장성에 열려 있는 것으로 설명하고 있다.
## 팩토리메서드 적용
- 객체 생성과 초기화의 분리
  - 객체 생성과 초기화를 분리하여 객체의 생성과정을 단순화시킵니다. 
  - 객체 생성과 초기화를 분리함으로써 객체 생성 시점에 필요한 정보를 모두 받아 객체를 생성할 수 있으며, 생성된 객체를 초기화할 때는 더 많은 자유도와 유연성을 가질 수 있습니다.
- 복잡한 객체 생성 지원
  - 팩토리 메서드는 복잡한 객체 생성을 지원할 수 있습니다. 
  - 예를 들어, 객체 생성 시점에 객체의 상태를 검증하거나, 다른 객체와의 연관 관계를 설정하거나, 객체의 생성 시점을 제한하는 등의 로직을 추가할 수 있습니다.
- 객체 생성의 중앙 집중화
  - 팩토리 메서드를 사용하여 객체 생성을 중앙 집중화함으로써 객체의 생성과 관련된 로직이 여러 곳에 흩어져 있는 경우를 방지할 수 있습니다.
  - 이를 통해 코드의 일관성을 유지하고, 유지 보수성을 향상시킬 수 있습니다.
- 객체의 생성 방법 변경 용이성
  - 팩토리 메서드를 사용하면 객체의 생성 방법을 변경하는 것이 용이해집니다
  - 예를 들어, 객체 생성 방법이 변경되어도 클라이언트 코드를 변경하지 않고도 새로운 객체를 생성할 수 있습니다. 이는 시스템을 변경하는 유연성과 확장성을 높여줍니다.
-> 결국, 생성역할을 분리함으로써 Validation 등을 적용할 수 있고 생성에 대한 확장성을 확보할 수 있음
예시    
- 팩토리 메서드를 사용하는 예시 코드를 보여드리겠습니다. 예를 들어, 주문(Order) 객체를 생성하는 팩토리 메서드를 구현한다고 가정해보겠습니다.
~~~java
public class OrderFactory {
  public static Order createOrder(Customer customer, List<Product> products) {
    Order order = new Order();
    order.setCustomer(customer);
    order.setProducts(products);
    order.setOrderDate(new Date());
    order.setStatus(OrderStatus.PLACED);
    return order;
  }
}
~~~
- 위 코드에서는 OrderFactory 클래스에 createOrder() 메서드를 정의하여 Order 객체를 생성합니다. 
- 이 메서드는 Customer와 Product 객체를 매개변수로 받아 Order 객체를 생성하고, 생성된 Order 객체의 속성을 초기화합니다. 
- 이 때, Order 객체의 생성과 초기화가 팩토리 메서드에서 한 번에 이루어집니다. 따라서 클라이언트에서는 Order 객체를 생성하는 코드를 단순화할 수 있습니다.
- 아래는 위에서 작성한 팩토리 메서드를 사용하여 Order 객체를 생성하는 코드입니다.
~~~java
  Customer customer = new Customer("홍길동", "hong@test.com", "010-1234-5678");
  List<Product> products = Arrays.asList(new Product("갤럭시 S21", 1000000), new Product("에어팟 프로", 250000));
  Order order = OrderFactory.createOrder(customer, products);
~~~

- 위 코드에서는 OrderFactory 클래스의 createOrder() 메서드를 호출하여 Order 객체를 생성합니다. 
- 이 때, 필요한 매개변수인 Customer와 Product 객체를 전달합니다. 
- 이렇게 하면 클라이언트에서는 Order 객체를 생성하고 초기화하는 데 필요한 코드를 작성할 필요 없이, 팩토리 메서드를 호출하는 코드만 작성하면 됩니다.


